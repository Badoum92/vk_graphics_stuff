#include "global.glsl"
#include "raytrace.glsl"

// #extension GL_EXT_debug_printf : enable

struct VoxelMaterial
{
    vec3 base_color;
    float metalness;
    vec3 emissive;
    float roughness;
};

const uint DIFFUSE = 0;
const uint METAL = 1;
const uint GLASS = 2;
const uint EMISSIVE = 3;

struct HitInfo
{
    vec3 pos;
    vec3 normal;
    uint voxel;
};

const uint MAX_BOUNCES = 4;

layout(set = 1, binding = 0, rgba8) uniform image2D output_image;
layout(set = 1, binding = 1, rgba8) uniform image2D output_image_acc;
layout(set = 1, binding = 2, r8ui) uniform uimage3D voxels;
layout(set = 1, binding = 3) buffer VoxelMaterials
{
    VoxelMaterial materials[];
};

void compute_normal(inout HitInfo hit_info, int last_step, ivec3 dir_step, vec3 bmin, vec3 bmax)
{
    hit_info.normal = vec3(0);
    if (last_step != -1)
    {
        hit_info.normal[last_step] = -dir_step[last_step];
        return;
    }
    for (uint i = 0; i < 3; ++i)
    {
        if (float_eq(hit_info.pos[i], bmin[i]))
        {
            hit_info.normal[i] = -1;
            break;
        }
        else if (float_eq(hit_info.pos[i], bmax[i]))
        {
            hit_info.normal[i] = 1;
            break;
        }
    }
}

void voxel_traversal(Ray ray, vec3 bmin, vec3 bmax, vec3 voxel_size, inout HitInfo hit_info)
{
    hit_info.voxel = 0;
    float tmin_ray = 0;
    float tmax_ray = 0;
    if (!ray_box_intersection(ray, bmin, bmax, tmin_ray, tmax_ray))
    {
        return;
    }

    const vec3 ray_start = clamp(ray.origin + ray.dir * tmin_ray, bmin, bmax);
    const vec3 ray_end = clamp(ray.origin + ray.dir * tmax_ray, bmin, bmax);
    ivec3 cur_index = max(ivec3(0), ivec3(ray_start - bmin / voxel_size));
    const ivec3 end_index = max(ivec3(0), ivec3(ray_end - bmin / voxel_size));

    vec3 tdelta = abs(voxel_size * ray.inv_dir);
    ivec3 dir_step = ivec3(0);
    vec3 tmax = vec3(0);

    for (uint i = 0; i < 3; ++i)
    {
        if (ray.dir[i] < 0)
        {
            dir_step[i] = -1;
            tmax[i] = (bmin[i] + cur_index[i] * voxel_size[i] - ray_start[i]) * ray.inv_dir[i];
        }
        else if (ray.dir[i] > 0)
        {
            dir_step[i] = 1;
            tmax[i] = (bmin[i] + (cur_index[i] + 1) * voxel_size[i] - ray_start[i]) * ray.inv_dir[i];
        }
    }

    int last_step = -1;
    float last_tmax = 0;
    do
    {
        hit_info.voxel = imageLoad(voxels, cur_index).r;
        if (hit_info.voxel != 0)
        {
            break;
        }

        if (tmax.x < tmax.y && tmax.x < tmax.z && cur_index.x != end_index.x)
        {
            last_step = 0;
        }
        else if (tmax.y < tmax.z && cur_index.y != end_index.y)
        {
            last_step = 1;
        }
        else if (cur_index.z != end_index.z)
        {
            last_step = 2;
        }
        else
        {
            return;
        }
        last_tmax = tmax[last_step];
        cur_index[last_step] += dir_step[last_step];
        tmax[last_step] += tdelta[last_step];
    } while (hit_info.voxel == 0);

    hit_info.pos = ray_start + ray.dir * last_tmax;
    compute_normal(hit_info, last_step, dir_step, bmin, bmax);
}

vec3 get_ray_color(Ray ray, inout uint rng_state)
{
    vec3 radiance = vec3(0.0f, 0.0f, 0.0f);
    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);

    vec3 offset = imageSize(voxels) / 2;
    for (uint bounce = 0; bounce <= MAX_BOUNCES; ++bounce)
    {
        HitInfo hit_info;
        voxel_traversal(ray, -offset, imageSize(voxels) - offset, vec3(1), hit_info);

        if (hit_info.voxel == 0)
        {
            float y = 0.5f * (ray.dir.y + 1.0f);
            vec3 miss_color = (1.0f - y) * vec3(1) + y * vec3(0.4f, 0.6f, 0.9f);
            // vec3 miss_color = vec3(0.0f, 0.0f, 0.004f);
            // vec3 miss_color = vec3(0);
            radiance += miss_color * throughput;
            break;
        }

        VoxelMaterial material = materials[hit_info.voxel];

        float do_specular = (random_float_01(rng_state) < material.metalness) ? 1.0f : 0.0f;
        vec3 diffuse_ray_dir = normalize(hit_info.normal + random_unit_vector(rng_state));
        vec3 specular_ray_dir = reflect(ray.dir, hit_info.normal);
        specular_ray_dir =
            normalize(mix(specular_ray_dir, diffuse_ray_dir, material.roughness * material.roughness));
        radiance += material.emissive * throughput;
        throughput *= material.base_color;

        radiance += material.emissive * throughput;
        throughput *= material.base_color;

        float p = min(0.95f, luminance(throughput.rgb));
        if (p < random_float_01(rng_state))
        {
            break;
        }
        throughput /= p;

        ray.origin = hit_info.pos + hit_info.normal * EPSILON;
        ray.dir = mix(diffuse_ray_dir, specular_ray_dir, do_specular);
        ray.inv_dir = 1.0f / ray.dir;

        /* radiance = material.base_color;
        break; */
        /* radiance = vec4(hit_info.normal, 1);
        for (uint i = 0; i < 3; ++i)
        {
            if (radiance[i] < 0)
            {
                radiance[i] = 0.01f;
            }
        }
        break; */
        /* radiance = vec4(hit_info.pos / imageSize(voxels), 1);
        break; */
    }
    return radiance;
}

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
    const ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

    if (any(greaterThan(pixel, global.resolution)))
    {
        return;
    }

    uint rng_state = init_rng(pixel, global.frame_number);
    Ray ray = ray_gen(pixel, true, rng_state);

    vec3 color = get_ray_color(ray, rng_state);
    color = clamp(color, vec3(0), vec3(1));

    vec3 color_acc = color;
    if (global.frame_number != 0)
    {
        color_acc += imageLoad(output_image_acc, pixel).rgb;
    }

    color = color_acc / (global.frame_number + 1);
    color *= global.exposure;
    color = ACES_tone_mapping(color);
    color = linear_to_srgb(color);

    imageStore(output_image_acc, pixel, vec4(color_acc, 1));
    imageStore(output_image, pixel, vec4(color, 1));
}
